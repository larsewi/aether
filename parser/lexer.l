%{
#include "parser_state.h"
#include "parser.h"  // Generated by 'yacc -d'

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "../utils/logger.h"
#include "../utils/string_lib.h"

#define P PARSER_STATE
%}

%%
[ \t]+ {
    P.col += yyleng;
}

\n {
    P.line += 1;
}

#[^\n]* {
    P.line += 1;
}

[_a-zA-Z][_a-zA-Z0-9]*

none

(true|false)

\"(\\.|[^"\\])*\" {
    LOG_DEBUG("Found string literal token '%s' (Ln %d, Col %d)", yytext, P.line, P.col);

    yylval.atom = malloc(sizeof(Atom));
    if (yylval.atom == NULL) {
        LOG_CRITICAL("Failed to allocate memory: %s", strerror(errno));
    }

    yylval.atom->type = ATOM_TYPE_STRING;
    assert(yyleng >= 2); /* two quotes */
    assert(yytext[0] == '"');
    assert(yytext[yyleng - 1] == '"');
    yylval.atom->literal.string_literal = StringDuplicate(yytext + 1);
    yylval.atom->literal.string_literal[yyleng - 2] = '\0';

    yylval.atom->line = P.line;
    yylval.atom->col = P.col;
    P.col += yyleng;
    return STRING_LITERAL;
}

(0|[1-9][0-9]*)\.[0-9]* {
    LOG_DEBUG("Found float literal token '%s' (Ln %d, Col %d)", yytext, P.line, P.col);

    yylval.atom = malloc(sizeof(Atom));
    if (yylval.atom == NULL) {
        LOG_CRITICAL("Failed to allocate memory: %s", strerror(errno));
    }

    yylval.atom->type = ATOM_TYPE_FLOAT;
    int ret = sscanf(yytext, "%lf", &(yylval.atom->literal.float_literal));
    if (ret != 1) {
        LOG_CRITICAL("Failed to scan float from token '%s'", yytext);
    }

    yylval.atom->line = P.line;
    yylval.atom->col = P.col;
    P.col += yyleng;
    return FLOAT_LITERAL;
}

(0|[1-9][0-9]*) {
    LOG_DEBUG("Found integer literal token '%s' (Ln %d, Col %d)", yytext, P.line, P.col);

    yylval.atom = malloc(sizeof(Atom));
    if (yylval.atom == NULL) {
        LOG_CRITICAL("Failed to allocate memory: %s", strerror(errno));
    }

    yylval.atom->type = ATOM_TYPE_INTEGER;
    int ret = sscanf(yytext, "%zu", &(yylval.atom->literal.integer_literal));
    if (ret != 1) {
        LOG_CRITICAL("Failed to scan integer from token '%s'", yytext);
    }

    yylval.atom->line = P.line;
    yylval.atom->col = P.col;
    P.col += yyleng;
    return INTEGER_LITERAL;
}

\|\| {
    P.col += yyleng;
    return OR_OPERATOR;
}

&& {
    P.col += yyleng;
    return AND_OPERATOR;
}

== {
    P.col += yyleng;
    return EQ_OPERATOR;
}

\<= {
    P.col += yyleng;
    return LE_OPERATOR;
}

>= {
    P.col += yyleng;
    return GE_OPERATOR;
}

!= {
    P.col += yyleng;
    return NE_OPERATOR;
}

%%

int yywrap() {
    return true;
}
