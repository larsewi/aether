%{
#include "syntax.h"

#include "parser.h"  // Generated by 'yacc -d'

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>

#include "../utils/alloc.h"
#include "../utils/logger.h"
#include "../utils/string_lib.h"

#define P PARSER_STATE
#define YY_USER_ACTION \
    yylloc.first_column = yylloc.last_column; \
    yylloc.last_column += yyleng; \
    if (!isspace(yytext[0])) { \
      LOG_DEBUG("Found token '%s' at Ln %d, Col %d", yytext, \
          yylloc.first_line, yylloc.first_column); \
    }


extern ParserState PARSER_STATE;
%}

%option nounput
%option noinput

%%
[ \t]+ {
  // Ignore spaces
  P.column += yyleng;
}

\n {
  // Ignore newlines
  P.line += 1;
  P.column = 1;
  yylloc.first_line += 1;
  yylloc.first_column = 1;
  yylloc.last_line += 1;
  yylloc.last_column = 1;
}

#[^\n]* {
  // Ignore comments
}

mut {
  return MUTABLE_KEYWORD;
}

none {
  SymbolNoneLiteral *none_literal = xmalloc(sizeof(SymbolNoneLiteral));
  none_literal->type = SYMBOL_TYPE_NONE_LITERAL;
  none_literal->first.line = yylloc.first_line;
  none_literal->first.column = yylloc.first_column;
  none_literal->last.line = yylloc.last_line;
  none_literal->last.column = yylloc.last_column;
  yylval.none_literal = none_literal;
  return NONE_LITERAL;
}

(true|false) {
  SymbolBooleanLiteral *boolean_literal = xmalloc(sizeof(SymbolBooleanLiteral));
  boolean_literal->type = SYMBOL_TYPE_BOOLEAN_LITERAL;
  boolean_literal->first.line = yylloc.first_line;
  boolean_literal->first.column = yylloc.first_column;
  boolean_literal->last.line = yylloc.last_line;
  boolean_literal->last.column = yylloc.last_column;
  boolean_literal->value = StringEqual(yytext, "true");
  yylval.boolean_literal = boolean_literal;
  return BOOLEAN_LITERAL;
}

\"(\\.|[^"\\])*\" {
  SymbolStringLiteral *string_literal = xmalloc(sizeof(SymbolStringLiteral));
  string_literal->type = SYMBOL_TYPE_STRING_LITERAL;
  string_literal->first.line = yylloc.first_line;
  string_literal->first.column = yylloc.first_column;
  string_literal->last.line = yylloc.last_line;
  string_literal->last.column = yylloc.last_column;
  assert(yyleng >= 2);
  string_literal->value = StringDuplicateN(yytext + 1, (size_t)(yyleng - 2));
  yylval.string_literal = string_literal;
  return STRING_LITERAL;
}

(0|[1-9][0-9]*)\.[0-9]* {
  SymbolFloatLiteral *float_literal = xmalloc(sizeof(SymbolFloatLiteral));
  float_literal->type = SYMBOL_TYPE_FLOAT_LITERAL;
  float_literal->first.line = yylloc.first_line;
  float_literal->first.column = yylloc.first_column;
  float_literal->last.line = yylloc.last_line;
  float_literal->last.column = yylloc.last_column;
  int ret = sscanf(yytext, "%lf", &float_literal->value);
  if (ret != 1) {
    LOG_CRITICAL("sscanf(3): Failed to scan float from string '%s': %s", yytext, strerror(errno));
  }
  yylval.float_literal = float_literal;
  return FLOAT_LITERAL;
}

(0|[1-9][0-9]*) {
  SymbolIntegerLiteral *integer_literal = xmalloc(sizeof(SymbolIntegerLiteral));
  integer_literal->type = SYMBOL_TYPE_INTEGER_LITERAL;
  integer_literal->first.line = yylloc.first_line;
  integer_literal->first.column = yylloc.first_column;
  integer_literal->last.line = yylloc.last_line;
  integer_literal->last.column = yylloc.last_column;
  int ret = sscanf(yytext, "%llu", &integer_literal->value);
  if (ret != 1) {
    LOG_CRITICAL("sscanf(3): Failed to scan float from string '%s': %s", yytext, ret, strerror(errno));
  }
  yylval.integer_literal = integer_literal;
  return INTEGER_LITERAL;
}

\|\| {
  return OR_OPER;
}

&& {
  return AND_OPER;
}

== {
  return EQ_OPER;
}

\<= {
  return LE_OPER;
}

>= {
  return GE_OPER;
}

!= {
  return NE_OPER;
}

. {
  return yytext[0];
}

[_a-zA-Z][_a-zA-Z0-9]* {
  SymbolIdentifier *identifier = xmalloc(sizeof(SymbolIdentifier));
  identifier->type = SYMBOL_TYPE_IDENTIFIER;
  identifier->first.line = yylloc.first_line;
  identifier->first.column = yylloc.first_column;
  identifier->last.line = yylloc.last_line;
  identifier->last.column = yylloc.last_column;
  identifier->value = StringDuplicate(yytext);
  yylval.identifier = identifier;
  return IDENTIFIER;
}

%%

int yywrap() {
  return true;
}
