%{
#include "syntax.h"

#include "parser.h"  // Generated by 'yacc -d'

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "../utils/alloc.h"
#include "../utils/logger.h"
#include "../utils/string_lib.h"

#define P PARSER_STATE
%}

%option nounput
%option noinput

%%
[ \t]+ {
  // Ignore spaces
  P.column += yyleng;
}

\n {
  // Ignore newlines
  P.line += 1;
  P.column = 1;
}

#[^\n]* {
  // Ignore comments
  P.line += 1;
  P.column = 1;
}

[_a-zA-Z][_a-zA-Z0-9]* {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolIdentifier *identifier = xmalloc(sizeof(SymbolIdentifier));
  identifier->type = SYMBOL_TYPE_IDENTIFIER;
  identifier->line = P.line;
  identifier->column = P.column;
  identifier->value = StringDuplicate(yytext);
  yylval.identifier = identifier;
  P.column += yyleng;
  return IDENTIFIER;
}

none {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolNoneLiteral *none_literal = xmalloc(sizeof(SymbolNoneLiteral));
  none_literal->type = SYMBOL_TYPE_NONE_LITERAL;
  none_literal->line = P.line;
  none_literal->column = P.column;
  yylval.none_literal = none_literal;
  P.column += yyleng;
  return NONE_LITERAL;
}

(true|false) {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolBooleanLiteral *boolean_literal = xmalloc(sizeof(SymbolBooleanLiteral));
  boolean_literal->type = SYMBOL_TYPE_BOOLEAN_LITERAL;
  boolean_literal->line = P.line;
  boolean_literal->column = P.column;
  boolean_literal->value = StringEqual(yytext, "true");
  yylval.boolean_literal = boolean_literal;
  P.column += yyleng;
  return BOOLEAN_LITERAL;
}

\"(\\.|[^"\\])*\" {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolStringLiteral *string_literal = xmalloc(sizeof(SymbolStringLiteral));
  string_literal->type = SYMBOL_TYPE_STRING_LITERAL;
  string_literal->line = P.line;
  string_literal->column = P.column;
  assert(yyleng >= 2);
  string_literal->value = StringDuplicateN(yytext + 1, (size_t)(yyleng - 2));
  yylval.string_literal = string_literal;
  P.column += yyleng;
  return STRING_LITERAL;
}

(0|[1-9][0-9]*)\.[0-9]* {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolFloatLiteral *float_literal = xmalloc(sizeof(SymbolFloatLiteral));
  float_literal->type = SYMBOL_TYPE_FLOAT_LITERAL;
  float_literal->line = P.line;
  float_literal->column = P.column;
  int ret = sscanf(yytext, "%lf", &float_literal->value);
  if (ret != 1) {
    LOG_CRITICAL("sscanf(3): Failed to scan float from string '%s': %s", yytext, strerror(errno));
  }
  yylval.float_literal = float_literal;
  P.column += yyleng;
  return FLOAT_LITERAL;
}

(0|[1-9][0-9]*) {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  SymbolIntegerLiteral *integer_literal = xmalloc(sizeof(SymbolIntegerLiteral));
  integer_literal->type = SYMBOL_TYPE_INTEGER_LITERAL;
  integer_literal->line = P.line;
  integer_literal->column = P.column;
  int ret = sscanf(yytext, "%llu", &integer_literal->value);
  if (ret != 1) {
    LOG_CRITICAL("sscanf(3): Failed to scan float from string '%s': %s", yytext, ret, strerror(errno));
  }
  yylval.integer_literal = integer_literal;
  P.column += yyleng;
  return INTEGER_LITERAL;
}

\|\| {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return OR_OPER;
}

&& {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return AND_OPER;
}

== {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return EQ_OPER;
}

\<= {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return LE_OPER;
}

>= {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return GE_OPER;
}

!= {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return NE_OPER;
}

. {
  LOG_DEBUG("Token '%s': Ln %d, Col %d", yytext, P.line, P.column);
  P.column += yyleng;
  return yytext[0];
}

%%

int yywrap() {
  return true;
}
